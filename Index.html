<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Paddle Tennis 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.8;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="loading">Loading realistic graphics...</div>
    <div id="info" style="display: none;">
        <strong>CONTROLS:</strong><br>
        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move<br>
        <span class="key">SPACE</span> - Swing / Serve<br>
        <span class="key">SHIFT</span> - Sprint<br>
        Mouse - Look Around
    </div>
    <div id="score" style="display: none;">Player: 0 | AI: 0</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Wait for Three.js to load
        window.addEventListener('load', () => {
            initGame();
        });

        function initGame() {
            // Scene setup with enhanced fog
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x226699, 0.008);
            
            // Camera with better FOV for sports games
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer with enhanced settings
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // Hide loading, show UI
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('score').style.display = 'block';

            // Create gradient sky
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077be) },
                    bottomColor: { value: new THREE.Color(0xffffff) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Main sun light with realistic color temperature
            const sunLight = new THREE.DirectionalLight(0xffd4a3, 1.5);
            sunLight.position.set(30, 40, 20);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -40;
            sunLight.shadow.camera.right = 40;
            sunLight.shadow.camera.top = 40;
            sunLight.shadow.camera.bottom = -40;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.bias = -0.0005;
            scene.add(sunLight);

            // Fill light to soften shadows
            const fillLight = new THREE.DirectionalLight(0x88aaff, 0.5);
            fillLight.position.set(-20, 30, -10);
            scene.add(fillLight);

            // Court dimensions (official paddle tennis)
            const courtWidth = 10;
            const courtLength = 20;
            const wallHeight = 4;
            const wallThickness = 0.15;

            // Enhanced court with PBR materials
            const courtGeometry = new THREE.BoxGeometry(courtWidth, 0.2, courtLength);
            
            // Create court texture with lines
            const courtCanvas = document.createElement('canvas');
            courtCanvas.width = 1024;
            courtCanvas.height = 2048;
            const ctx = courtCanvas.getContext('2d');
            
            // Blue synthetic court base
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(0, 0, courtCanvas.width, courtCanvas.height);
            
            // Add texture pattern
            for(let i = 0; i < 20000; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.05})`;
                ctx.fillRect(
                    Math.random() * courtCanvas.width,
                    Math.random() * courtCanvas.height,
                    2, 2
                );
            }
            
            // Court lines
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 10;
            
            // Service line (3 meters from net on each side)
            const serviceLinePosition = courtCanvas.height * 0.35; // 3m from center
            ctx.beginPath();
            ctx.moveTo(0, serviceLinePosition);
            ctx.lineTo(courtCanvas.width, serviceLinePosition);
            ctx.moveTo(0, courtCanvas.height - serviceLinePosition);
            ctx.lineTo(courtCanvas.width, courtCanvas.height - serviceLinePosition);
            ctx.stroke();
            
            // Center line (divides service boxes)
            ctx.beginPath();
            ctx.moveTo(courtCanvas.width / 2, serviceLinePosition);
            ctx.lineTo(courtCanvas.width / 2, courtCanvas.height - serviceLinePosition);
            ctx.stroke();
            
            // Side lines
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(50, 0);
            ctx.lineTo(50, courtCanvas.height);
            ctx.moveTo(courtCanvas.width - 50, 0);
            ctx.lineTo(courtCanvas.width - 50, courtCanvas.height);
            ctx.stroke();
            
            const courtTexture = new THREE.CanvasTexture(courtCanvas);
            courtTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            const courtMaterial = new THREE.MeshStandardMaterial({ 
                map: courtTexture,
                roughness: 0.8,
                metalness: 0.05,
                bumpScale: 0.001
            });
            
            const court = new THREE.Mesh(courtGeometry, courtMaterial);
            court.receiveShadow = true;
            scene.add(court);

            // Add court boundary walls (lower part - solid)
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.7,
                metalness: 0.3
            });

            // Create black metal frame structure
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.4,
                metalness: 0.8
            });

            // Create wall segments with frames
            const createWallSegment = (width, height, depth, x, y, z) => {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const mesh = new THREE.Mesh(geometry, frameMaterial);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            };

            // Frame thickness
            const frameSize = 0.05;
            
            // Bottom frame around court
            scene.add(createWallSegment(courtWidth + wallThickness * 2, 0.3, wallThickness, 0, 0.15, -courtLength/2));
            scene.add(createWallSegment(courtWidth + wallThickness * 2, 0.3, wallThickness, 0, 0.15, courtLength/2));
            scene.add(createWallSegment(wallThickness, 0.3, courtLength, -courtWidth/2 - wallThickness/2, 0.15, 0));
            scene.add(createWallSegment(wallThickness, 0.3, courtLength, courtWidth/2 + wallThickness/2, 0.15, 0));

            // Glass walls - higher and more visible
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.7,
                thickness: 0.3,
                transparent: true,
                opacity: 0.4,
                ior: 1.5,
                reflectivity: 0.5,
                side: THREE.DoubleSide
            });

            const glassHeight = 3.5;
            
            // Back glass walls
            const backGlass1 = new THREE.Mesh(
                new THREE.BoxGeometry(courtWidth, glassHeight, 0.05),
                glassMaterial
            );
            backGlass1.position.set(0, glassHeight/2 + 0.3, -courtLength/2);
            scene.add(backGlass1);

            const backGlass2 = new THREE.Mesh(
                new THREE.BoxGeometry(courtWidth, glassHeight, 0.05),
                glassMaterial
            );
            backGlass2.position.set(0, glassHeight/2 + 0.3, courtLength/2);
            scene.add(backGlass2);

            // Side walls with metal grid/mesh (like in the photo)
            const createMetalGrid = (width, height, x, z) => {
                const gridGroup = new THREE.Group();
                
                // Vertical bars
                const barGeometry = new THREE.CylinderGeometry(0.01, 0.01, height);
                const barMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    roughness: 0.5,
                    metalness: 0.8
                });
                
                for(let i = 0; i < width; i += 0.2) {
                    const bar = new THREE.Mesh(barGeometry, barMaterial);
                    bar.position.set(x, height/2 + 0.3, z - width/2 + i);
                    bar.castShadow = true;
                    gridGroup.add(bar);
                }
                
                // Horizontal bars
                const hBarGeometry = new THREE.CylinderGeometry(0.01, 0.01, width);
                for(let i = 0; i < height; i += 0.2) {
                    const bar = new THREE.Mesh(hBarGeometry, barMaterial);
                    bar.rotation.z = Math.PI / 2;
                    bar.position.set(x, i + 0.3, z);
                    bar.castShadow = true;
                    gridGroup.add(bar);
                }
                
                return gridGroup;
            };

            // Add side grids
            scene.add(createMetalGrid(courtLength, glassHeight, -courtWidth/2, 0));
            scene.add(createMetalGrid(courtLength, glassHeight, courtWidth/2, 0));

            // Metal frame for all panels
            const frameThickness = 0.05;
            const createFrame = (w, h, d, x, y, z) => {
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    frameMaterial
                );
                frame.position.set(x, y, z);
                frame.castShadow = true;
                return frame;
            };

            // Vertical corner frames
            for(let corner of [[-courtWidth/2, -courtLength/2], [courtWidth/2, -courtLength/2], 
                              [-courtWidth/2, courtLength/2], [courtWidth/2, courtLength/2]]) {
                scene.add(createFrame(frameThickness*2, wallHeight, frameThickness*2, corner[0], wallHeight/2, corner[1]));
            }

            // Top horizontal frames
            scene.add(createFrame(courtWidth, frameThickness, frameThickness, 0, wallHeight, -courtLength/2));
            scene.add(createFrame(courtWidth, frameThickness, frameThickness, 0, wallHeight, courtLength/2));
            scene.add(createFrame(frameThickness, frameThickness, courtLength, -courtWidth/2, wallHeight, 0));
            scene.add(createFrame(frameThickness, frameThickness, courtLength, courtWidth/2, wallHeight, 0));

            // Net with realistic mesh
            const netHeight = 0.92;
            const netGeometry = new THREE.PlaneGeometry(courtWidth, netHeight, 40, 20);
            
            // Modify vertices for net sag
            const netPositions = netGeometry.attributes.position;
            for(let i = 0; i < netPositions.count; i++) {
                const x = netPositions.getX(i);
                const y = netPositions.getY(i);
                const sag = Math.sin((x / courtWidth + 0.5) * Math.PI) * 0.05;
                netPositions.setY(i, y - sag);
            }
            
            const netMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                alphaTest: 0.1,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.y = netHeight / 2;
            net.rotation.x = Math.PI / 2;
            net.castShadow = true;
            scene.add(net);

            // Net posts
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, netHeight + 0.2);
            const postMaterial = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.3,
                metalness: 0.8
            });
            
            const post1 = new THREE.Mesh(postGeometry, postMaterial);
            post1.position.set(-courtWidth/2, (netHeight + 0.2)/2, 0);
            post1.castShadow = true;
            scene.add(post1);
            
            const post2 = new THREE.Mesh(postGeometry, postMaterial);
            post2.position.set(courtWidth/2, (netHeight + 0.2)/2, 0);
            post2.castShadow = true;
            scene.add(post2);

            // Enhanced Player class with better visuals
            class Player {
                constructor(x, z, isAI = false) {
                    this.group = new THREE.Group();
                    
                    // More realistic body proportions
                    const skinMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffdbac,
                        roughness: 0.7,
                        metalness: 0.0
                    });
                    
                    const shirtMaterial = new THREE.MeshStandardMaterial({ 
                        color: isAI ? 0xcc0000 : 0x0066cc,
                        roughness: 0.8,
                        metalness: 0.0
                    });
                    
                    const shortsMaterial = new THREE.MeshStandardMaterial({ 
                        color: isAI ? 0x660000 : 0x003366,
                        roughness: 0.9,
                        metalness: 0.0
                    });
                    
                    // Torso
                    const torsoGeometry = new THREE.CylinderGeometry(0.35, 0.3, 1.0, 12);
                    this.torso = new THREE.Mesh(torsoGeometry, shirtMaterial);
                    this.torso.position.y = 1.2;
                    this.torso.castShadow = true;
                    this.torso.receiveShadow = true;
                    this.group.add(this.torso);
                    
                    // Shorts
                    const shortsGeometry = new THREE.CylinderGeometry(0.3, 0.25, 0.4, 12);
                    this.shorts = new THREE.Mesh(shortsGeometry, shortsMaterial);
                    this.shorts.position.y = 0.5;
                    this.shorts.castShadow = true;
                    this.group.add(this.shorts);
                    
                    // Head
                    const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    this.head = new THREE.Mesh(headGeometry, skinMaterial);
                    this.head.position.y = 1.9;
                    this.head.castShadow = true;
                    this.group.add(this.head);
                    
                    // Arms
                    const armGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.8, 8);
                    
                    this.leftArm = new THREE.Mesh(armGeometry, skinMaterial);
                    this.leftArm.position.set(-0.35, 1.2, 0);
                    this.leftArm.rotation.z = 0.2;
                    this.leftArm.castShadow = true;
                    this.group.add(this.leftArm);
                    
                    this.rightArm = new THREE.Mesh(armGeometry, skinMaterial);
                    this.rightArm.position.set(0.35, 1.2, 0);
                    this.rightArm.rotation.z = -0.2;
                    this.rightArm.castShadow = true;
                    this.group.add(this.rightArm);
                    
                    // Legs
                    const legGeometry = new THREE.CylinderGeometry(0.1, 0.08, 1.0, 8);
                    
                    this.leftLeg = new THREE.Mesh(legGeometry, skinMaterial);
                    this.leftLeg.position.set(-0.15, -0.2, 0);
                    this.leftLeg.castShadow = true;
                    this.group.add(this.leftLeg);
                    
                    this.rightLeg = new THREE.Mesh(legGeometry, skinMaterial);
                    this.rightLeg.position.set(0.15, -0.2, 0);
                    this.rightLeg.castShadow = true;
                    this.group.add(this.rightLeg);
                    
                    // Shoes
                    const shoeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.6,
                        metalness: 0.0
                    });
                    
                    const shoeGeometry = new THREE.BoxGeometry(0.12, 0.08, 0.25);
                    
                    this.leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                    this.leftShoe.position.set(-0.15, -0.74, 0.05);
                    this.leftShoe.castShadow = true;
                    this.group.add(this.leftShoe);
                    
                    this.rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                    this.rightShoe.position.set(0.15, -0.74, 0.05);
                    this.rightShoe.castShadow = true;
                    this.group.add(this.rightShoe);
                    
                    // Enhanced paddle with realistic materials
                    const paddleGroup = new THREE.Group();
                    
                    // Paddle face
                    const paddleFaceGeometry = new THREE.BoxGeometry(0.45, 0.02, 0.5);
                    const paddleFaceMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        roughness: 0.2,
                        metalness: 0.1
                    });
                    const paddleFace = new THREE.Mesh(paddleFaceGeometry, paddleFaceMaterial);
                    paddleFace.castShadow = true;
                    paddleGroup.add(paddleFace);
                    
                    // Paddle edge
                    const paddleEdgeGeometry = new THREE.TorusGeometry(0.24, 0.02, 4, 20);
                    const paddleEdgeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff6600,
                        roughness: 0.3,
                        metalness: 0.2
                    });
                    const paddleEdge = new THREE.Mesh(paddleEdgeGeometry, paddleEdgeMaterial);
                    paddleEdge.rotation.x = Math.PI / 2;
                    paddleGroup.add(paddleEdge);
                    
                    // Handle
                    const handleGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.3, 12);
                    const handleMaterial = new THREE.MeshStandardMaterial({
                        color: 0x4a4a4a,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                    handle.position.y = -0.25;
                    handle.castShadow = true;
                    paddleGroup.add(handle);
                    
                    // Grip
                    const gripGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8);
                    const gripMaterial = new THREE.MeshStandardMaterial({
                        color: 0x222222,
                        roughness: 0.9,
                        metalness: 0.0
                    });
                    const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                    grip.position.y = -0.3;
                    paddleGroup.add(grip);
                    
                    this.paddle = paddleGroup;
                    this.paddle.position.set(0.5, 1.2, 0);
                    this.group.add(this.paddle);
                    
                    // Set initial position
                    this.group.position.set(x, 0.7, z);
                    scene.add(this.group);
                    
                    // Movement properties
                    this.velocity = { x: 0, z: 0 };
                    this.targetRotation = 0;
                    this.swinging = false;
                    this.swingTimer = 0;
                    this.isAI = isAI;
                    this.speed = 5;
                    this.sprintMultiplier = 1.8;
                    this.isSprinting = false;
                    this.canHit = true;
                    
                    // Animation properties
                    this.walkCycle = 0;
                    this.armSwing = 0;
                }

                update(deltaTime) {
                    // Smooth movement
                    const moveSpeed = this.speed * (this.isSprinting ? this.sprintMultiplier : 1);
                    
                    this.group.position.x += this.velocity.x * moveSpeed * deltaTime;
                    this.group.position.z += this.velocity.z * moveSpeed * deltaTime;
                    
                    // Keep within court bounds - prevent crossing net
                    const minZ = this.isAI ? -courtLength/2 + 0.5 : 0.5;
                    const maxZ = this.isAI ? -0.5 : courtLength/2 - 0.5;
                    
                    this.group.position.x = Math.max(-courtWidth/2 + 0.5, Math.min(courtWidth/2 - 0.5, this.group.position.x));
                    this.group.position.z = Math.max(minZ, Math.min(maxZ, this.group.position.z));
                    
                    // Rotate player based on movement direction
                    if (Math.abs(this.velocity.x) > 0.01 || Math.abs(this.velocity.z) > 0.01) {
                        this.targetRotation = Math.atan2(this.velocity.x, this.velocity.z);
                        
                        // Walking animation
                        this.walkCycle += deltaTime * 10 * moveSpeed / this.speed;
                        const walkAmplitude = 0.1;
                        
                        // Leg animation
                        this.leftLeg.rotation.x = Math.sin(this.walkCycle) * walkAmplitude;
                        this.rightLeg.rotation.x = -Math.sin(this.walkCycle) * walkAmplitude;
                        
                        // Subtle body bob
                        this.group.position.y = 0.7 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.02;
                        
                        // Arm swing when not holding paddle ready
                        if (!this.swinging) {
                            this.leftArm.rotation.x = -Math.sin(this.walkCycle) * walkAmplitude * 0.5;
                        }
                    } else {
                        // Idle animation
                        this.walkCycle += deltaTime * 2;
                        this.group.position.y = 0.7 + Math.sin(this.walkCycle) * 0.01;
                    }
                    
                    // Smooth rotation
                    const rotationDiff = this.targetRotation - this.group.rotation.y;
                    this.group.rotation.y += rotationDiff * deltaTime * 10;
                    
                    // Swing mechanics
                    if (this.swinging) {
                        this.swingTimer += deltaTime * 8; // Slower swing for better timing
                        const swingProgress = this.swingTimer / Math.PI;
                        
                        // Wider swing motion
                        const swingAngle = Math.sin(this.swingTimer) * Math.PI / 1.5;
                        const liftAngle = Math.sin(this.swingTimer * 0.5) * Math.PI / 6;
                        
                        this.rightArm.rotation.x = -liftAngle - 0.3;
                        this.rightArm.rotation.z = -0.2 - swingAngle * 0.5;
                        
                        this.paddle.rotation.y = swingAngle;
                        this.paddle.rotation.z = liftAngle * 0.3;
                        this.paddle.position.x = 0.5 + Math.sin(swingAngle) * 0.5;
                        this.paddle.position.y = 1.2 + Math.sin(liftAngle) * 0.1;
                        
                        // Body rotation during swing
                        this.torso.rotation.y = swingAngle * 0.3;
                        
                        if (this.swingTimer > Math.PI) {
                            this.swinging = false;
                            this.swingTimer = 0;
                            this.paddle.rotation.y = 0;
                            this.paddle.rotation.z = 0;
                            this.rightArm.rotation.x = 0;
                            this.rightArm.rotation.z = -0.2;
                            this.torso.rotation.y = 0;
                        }
                    } else {
                        // Ready position - paddle in front
                        this.paddle.position.x = 0.7;
                        this.paddle.position.y = 1.2;
                        this.paddle.position.z = -0.3 * Math.sign(this.group.position.z);
                        this.rightArm.rotation.x = -0.3;
                    }
                }

                swing() {
                    if (!this.swinging) {
                        this.swinging = true;
                        this.swingTimer = 0;
                    }
                }
            }

            // Create players
            const player = new Player(0, courtLength/2 - 2);
            const aiPlayer = new Player(0, -courtLength/2 + 2, true);

            // Enhanced ball with better materials
            const ballGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                roughness: 0.2,
                metalness: 0.0,
                emissive: 0x00ff00,
                emissiveIntensity: 0.3
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.receiveShadow = true;
            ball.position.set(0, 1, 0);
            scene.add(ball);

            // Add glowing outline to ball
            const glowGeometry = new THREE.SphereGeometry(0.12, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const ballGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            ball.add(ballGlow);

            // Add ball trail effect
            const trailGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.6
            });
            const ballTrails = [];
            for(let i = 0; i < 10; i++) {
                const trail = new THREE.Mesh(trailGeometry, trailMaterial.clone());
                trail.visible = false;
                scene.add(trail);
                ballTrails.push(trail);
            }

            // Enhanced ball physics
            let ballVelocity = { x: 0, y: 0, z: -5 };
            let ballSpin = { x: 0, y: 0, z: 0 };
            const gravity = -9.81;
            const bounceDamping = 0.75;
            const airResistance = 0.99;
            const spinEffect = 0.001;
            const maxBallSpeed = 25;

            // Game state
            let playerScore = 0;
            let aiScore = 0;
            let serving = true;
            let servePosition = 'right';
            let ballBounces = 0;
            let lastHitBy = null;
            let currentServer = 'player'; // who is serving
            let serveCount = 0; // count serves to alternate
            const serviceLine = 3; // 3 meters from net

            // Keyboard controls
            const keys = {};
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                e.preventDefault();
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                e.preventDefault();
            });

            // Mouse controls for camera
            let mouseX = 0;
            let mouseY = 0;
            let cameraDistance = 12;
            let cameraHeight = 8;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            document.addEventListener('wheel', (e) => {
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(10, Math.min(30, cameraDistance));
            });

            // Update ball physics with enhanced realism
            function updateBall(deltaTime) {
                if (serving) {
                    // Position ball for serve based on who's serving
                    if (currentServer === 'player') {
                        // Player must serve from behind service line
                        const serveX = servePosition === 'right' ? 2 : -2;
                        const serveZ = courtLength/2 - serviceLine - 0.5;
                        ball.position.set(
                            player.group.position.x,
                            1.5,
                            Math.min(player.group.position.z - 0.3, serveZ)
                        );
                    } else {
                        // AI serves
                        const serveX = servePosition === 'right' ? 2 : -2;
                        const serveZ = -courtLength/2 + serviceLine + 0.5;
                        ball.position.set(
                            aiPlayer.group.position.x,
                            1.5,
                            Math.max(aiPlayer.group.position.z + 0.3, serveZ)
                        );
                    }
                    
                    // Hide trail during serve
                    ballTrails.forEach(trail => trail.visible = false);
                    return;
                }

                // Apply physics
                ballVelocity.y += gravity * deltaTime;
                
                // Air resistance
                ballVelocity.x *= Math.pow(airResistance, deltaTime * 60);
                ballVelocity.z *= Math.pow(airResistance, deltaTime * 60);
                
                // Apply spin effect (Magnus effect)
                ballVelocity.x += ballSpin.y * spinEffect;
                ballVelocity.z -= ballSpin.x * spinEffect;
                
                // Update position
                const prevPos = ball.position.clone();
                ball.position.x += ballVelocity.x * deltaTime;
                ball.position.y += ballVelocity.y * deltaTime;
                ball.position.z += ballVelocity.z * deltaTime;
                
                // Update ball trail
                for(let i = ballTrails.length - 1; i > 0; i--) {
                    ballTrails[i].position.copy(ballTrails[i-1].position);
                    ballTrails[i].material.opacity = 0.3 * (1 - i / ballTrails.length);
                    ballTrails[i].visible = true;
                }
                ballTrails[0].position.copy(prevPos);
                
                // Apply spin to rotation
                ball.rotation.x += ballSpin.x * deltaTime;
                ball.rotation.y += ballSpin.y * deltaTime;
                ball.rotation.z += ballSpin.z * deltaTime;
                
                // Ground bounce
                if (ball.position.y <= 0.1) {
                    ball.position.y = 0.1;
                    ballVelocity.y = Math.abs(ballVelocity.y) * bounceDamping;
                    ballBounces++;
                    
                    // Reduce spin on bounce
                    ballSpin.x *= 0.8;
                    ballSpin.y *= 0.8;
                    ballSpin.z *= 0.8;
                    
                    // Check if ball has bounced twice on the ground
                    if (ballBounces > 1) {
                        // Point scoring based on where ball bounced
                        if (ball.position.z > 0) {
                            aiScore++;
                        } else {
                            playerScore++;
                        }
                        
                        // Alternate server every 2 points
                        serveCount++;
                        if (serveCount >= 2) {
                            currentServer = currentServer === 'player' ? 'ai' : 'player';
                            serveCount = 0;
                        }
                        
                        resetBall();
                    }
                }
                
                // GLASS WALL BOUNCES - CRITICAL FOR PADDLE TENNIS
                // Back wall bounces
                if (ball.position.z >= courtLength/2 - 0.15) {
                    ball.position.z = courtLength/2 - 0.15;
                    ballVelocity.z = -Math.abs(ballVelocity.z) * 0.8;
                    createWallHitEffect(ball.position.x, ball.position.y, ball.position.z);
                    // Ball is still in play after wall bounce!
                    // DO NOT reset bounce count - ball can bounce on floor then wall
                }
                
                if (ball.position.z <= -courtLength/2 + 0.15) {
                    ball.position.z = -courtLength/2 + 0.15;
                    ballVelocity.z = Math.abs(ballVelocity.z) * 0.8;
                    createWallHitEffect(ball.position.x, ball.position.y, ball.position.z);
                    // Ball is still in play after wall bounce!
                    // DO NOT reset bounce count - ball can bounce on floor then wall
                }
                
                // Side wall bounces
                if (Math.abs(ball.position.x) >= courtWidth/2 - 0.15) {
                    ballVelocity.x = -ballVelocity.x * 0.8;
                    ball.position.x = Math.sign(ball.position.x) * (courtWidth/2 - 0.15);
                    createWallHitEffect(ball.position.x, ball.position.y, ball.position.z);
                    // DO NOT reset bounce count - ball can bounce on floor then wall
                }
                
                // Ball out of bounds check (only if it goes outside the walls somehow)
                if (ball.position.x < -courtWidth/2 - 1 || 
                    ball.position.x > courtWidth/2 + 1 ||
                    ball.position.z < -courtLength/2 - 1 || 
                    ball.position.z > courtLength/2 + 1 ||
                    ball.position.y < -5) {
                    resetBall();
                }
                
                // Enhanced net collision
                const netDistance = 0.1;
                if (Math.abs(ball.position.z) < netDistance && 
                    ball.position.y < 0.92 && 
                    ball.position.y > 0) {
                    
                    // Ball hits the net
                    if (Math.abs(ballVelocity.z) > 2) {
                        // Strong hit - ball bounces back
                        ballVelocity.z = -ballVelocity.z * 0.3;
                        ballVelocity.y *= 0.5;
                        ball.position.z = Math.sign(ball.position.z) * netDistance;
                        
                        // Net hit counts as fault
                        if (lastHitBy === 'player') {
                            aiScore++;
                        } else if (lastHitBy === 'ai') {
                            playerScore++;
                        }
                        resetBall();
                    } else {
                        // Weak hit - ball drops
                        ballVelocity.z *= 0.1;
                        ballVelocity.y = -Math.abs(ballVelocity.y) * 0.5;
                    }
                }
                
                // Check paddle collisions - check both players every frame
                if (!serving) {
                    checkPaddleCollision(player, 'player');
                    checkPaddleCollision(aiPlayer, 'ai');
                }
            }

            // Create wall hit particle effect
            function createWallHitEffect(x, y, z) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5
                });
                
                for(let i = 0; i < 5; i++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                    particle.position.set(x, y, z);
                    scene.add(particle);
                    
                    // Animate particle
                    const velocity = {
                        x: (Math.random() - 0.5) * 2,
                        y: Math.random() * 2,
                        z: (Math.random() - 0.5) * 2
                    };
                    
                    const animateParticle = () => {
                        particle.position.x += velocity.x * 0.02;
                        particle.position.y += velocity.y * 0.02;
                        particle.position.z += velocity.z * 0.02;
                        particle.material.opacity -= 0.02;
                        
                        if (particle.material.opacity > 0) {
                            requestAnimationFrame(animateParticle);
                        } else {
                            scene.remove(particle);
                        }
                    };
                    
                    animateParticle();
                }
            }

            // Enhanced paddle collision with spin
            function checkPaddleCollision(playerObj, playerType) {
                const paddleWorldPos = new THREE.Vector3();
                playerObj.paddle.getWorldPosition(paddleWorldPos);
                
                // Check if ball is in hitting range
                const horizontalDistance = Math.sqrt(
                    Math.pow(ball.position.x - paddleWorldPos.x, 2) +
                    Math.pow(ball.position.z - paddleWorldPos.z, 2)
                );
                
                const verticalRange = Math.abs(ball.position.y - paddleWorldPos.y) < 1.5;
                
                // MUCH larger hit detection area for easier gameplay
                if (horizontalDistance < 1.5 && verticalRange && playerObj.swinging) {
                    
                    // Simple, predictable hit direction
                    let targetZ = playerObj.isAI ? 8 : -8; // Always hit toward opponent's side
                    let targetX = 0; // Default center
                    
                    // Add some horizontal variation based on paddle position
                    if (paddleWorldPos.x < ball.position.x) {
                        targetX = 2; // Hit to the right
                    } else if (paddleWorldPos.x > ball.position.x) {
                        targetX = -2; // Hit to the left
                    }
                    
                    // Consistent, moderate power
                    const power = 10;
                    
                    // Calculate direction to target
                    const direction = new THREE.Vector3(
                        targetX - ball.position.x,
                        0.5, // Consistent upward angle
                        targetZ - ball.position.z
                    ).normalize();
                    
                    ballVelocity.x = direction.x * power;
                    ballVelocity.y = direction.y * power + 3; // Extra lift
                    ballVelocity.z = direction.z * power;
                    
                    // Minimal spin for predictability
                    ballSpin.x = (Math.random() - 0.5) * 5;
                    ballSpin.y = (Math.random() - 0.5) * 3;
                    ballSpin.z = (Math.random() - 0.5) * 5;
                    
                    // Reset bounces and update last hit
                    ballBounces = 0;
                    lastHitBy = playerType;
                    
                    // Visual and audio feedback
                    ballMaterial.emissiveIntensity = 0.8;
                    setTimeout(() => {
                        ballMaterial.emissiveIntensity = 0.3;
                    }, 200);
                    
                    // Prevent double hits
                    playerObj.canHit = false;
                    setTimeout(() => {
                        playerObj.canHit = true;
                    }, 500);
                }
            }

            function resetBall() {
                serving = true;
                ballVelocity = { x: 0, y: 0, z: -5 };
                ballSpin = { x: 0, y: 0, z: 0 };
                ballBounces = 0;
                lastHitBy = null;
                servePosition = servePosition === 'right' ? 'left' : 'right';
            }

            // Enhanced AI behavior
            function updateAI(deltaTime) {
                const ballPrediction = predictBallPosition();
                
                if (currentServer === 'ai' && serving) {
                    // AI needs to serve
                    const serveX = servePosition === 'right' ? 2 : -2;
                    const serveZ = -courtLength/2 + serviceLine - 0.5;
                    
                    // Move to service position
                    aiPlayer.velocity.x = (serveX - aiPlayer.group.position.x) * 0.1;
                    aiPlayer.velocity.z = (serveZ - aiPlayer.group.position.z) * 0.1;
                    
                    // Serve when in position
                    if (Math.abs(aiPlayer.group.position.x - serveX) < 0.5 &&
                        Math.abs(aiPlayer.group.position.z - serveZ) < 0.5) {
                        aiPlayer.swing();
                        serving = false;
                        const serveDirection = servePosition === 'right' ? -1 : 1;
                        ballVelocity = { 
                            x: serveDirection * 2, 
                            y: 4, 
                            z: 8
                        };
                        ballSpin = {
                            x: (Math.random() - 0.5) * 10,
                            y: serveDirection * 3,
                            z: (Math.random() - 0.5) * 5
                        };
                        lastHitBy = 'ai';
                    }
                    return;
                }
                
                if (ball.position.z < 0 || ballPrediction.z < 0) {
                    // AI movement and positioning
                    const targetX = ball.position.x * 0.8; // Anticipate ball position
                    const optimalZ = ballPrediction.z > -5 ? -3 : -courtLength/2 + 2.5;
                    const targetZ = Math.max(ballPrediction.z + 0.5, optimalZ);
                    
                    const dx = targetX - aiPlayer.group.position.x;
                    const dz = targetZ - aiPlayer.group.position.z;
                    
                    // Improved AI movement
                    const maxSpeed = 0.9;
                    const acceleration = 0.15;
                    
                    // Smoother acceleration
                    if (Math.abs(dx) > 0.2) {
                        aiPlayer.velocity.x += Math.sign(dx) * acceleration;
                    } else {
                        aiPlayer.velocity.x *= 0.8; // Decelerate when close
                    }
                    
                    if (Math.abs(dz) > 0.2) {
                        aiPlayer.velocity.z += Math.sign(dz) * acceleration;
                    } else {
                        aiPlayer.velocity.z *= 0.8; // Decelerate when close
                    }
                    
                    // Limit speed
                    const currentSpeed = Math.sqrt(aiPlayer.velocity.x ** 2 + aiPlayer.velocity.z ** 2);
                    if (currentSpeed > maxSpeed) {
                        aiPlayer.velocity.x = (aiPlayer.velocity.x / currentSpeed) * maxSpeed;
                        aiPlayer.velocity.z = (aiPlayer.velocity.z / currentSpeed) * maxSpeed;
                    }
                    
                    // Improved swing decision
                    const ballDistance = Math.sqrt(
                        Math.pow(ball.position.x - aiPlayer.group.position.x, 2) +
                        Math.pow(ball.position.z - aiPlayer.group.position.z, 2)
                    );
                    
                    // AI swings when ball is in range and moving toward it
                    if (ballDistance < 1.8 && 
                        !aiPlayer.swinging && 
                        aiPlayer.canHit &&
                        ball.position.y < 2.5 &&
                        ball.position.y > 0.2 &&
                        ball.position.z < -0.5 && // Ball is on AI's side
                        ballVelocity.z < 5) { // Not moving away too fast
                        
                        aiPlayer.swing();
                    }
                } else {
                    // Return to center position
                    const centerX = 0;
                    const centerZ = -courtLength/2 + 2;
                    
                    aiPlayer.velocity.x = (centerX - aiPlayer.group.position.x) * 0.05;
                    aiPlayer.velocity.z = (centerZ - aiPlayer.group.position.z) * 0.05;
                }
            }
            
            // Predict where ball will be
            function predictBallPosition() {
                let futurePos = ball.position.clone();
                let futureVel = { ...ballVelocity };
                const timeStep = 0.05;
                const maxTime = 1.5;
                
                for(let t = 0; t < maxTime; t += timeStep) {
                    futureVel.y += gravity * timeStep;
                    futurePos.x += futureVel.x * timeStep;
                    futurePos.y += futureVel.y * timeStep;
                    futurePos.z += futureVel.z * timeStep;
                    
                    // Predict wall bounces
                    if (Math.abs(futurePos.z) >= courtLength/2 - 0.15) {
                        futureVel.z *= -0.8;
                    }
                    if (Math.abs(futurePos.x) >= courtWidth/2 - 0.15) {
                        futureVel.x *= -0.8;
                    }
                    
                    if (futurePos.y <= 1.0 && futurePos.z < 0) {
                        break;
                    }
                }
                
                return futurePos;
            }

            // Camera setup
            camera.position.set(0, cameraHeight, courtLength/2 + cameraDistance);
            camera.lookAt(0, 0, 0);

            // Game loop
            const clock = new THREE.Clock();
            let frameCount = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                
                const deltaTime = Math.min(clock.getDelta(), 0.02); // Cap delta time
                frameCount++;
                
                // Player controls
                player.velocity.x = 0;
                player.velocity.z = 0;
                
                if (keys['w']) player.velocity.z = -1;
                if (keys['s']) player.velocity.z = 1;
                if (keys['a']) player.velocity.x = -1;
                if (keys['d']) player.velocity.x = 1;
                
                // Normalize diagonal movement
                if (player.velocity.x !== 0 && player.velocity.z !== 0) {
                    player.velocity.x *= 0.707;
                    player.velocity.z *= 0.707;
                }
                
                // Sprint
                player.isSprinting = keys['shift'];
                
                // Swing
                if (keys[' ']) {
                    if (currentServer === 'player') {
                        player.swing();
                        if (serving) {
                            // Check if player is behind service line
                            if (player.group.position.z <= courtLength/2 - serviceLine) {
                                serving = false;
                                const serveDirection = servePosition === 'right' ? 1 : -1;
                                ballVelocity = { 
                                    x: serveDirection * 3 + (Math.random() - 0.5) * 2, 
                                    y: 6, 
                                    z: -12 - Math.random() * 3 
                                };
                                ballSpin = {
                                    x: (Math.random() - 0.5) * 15,
                                    y: serveDirection * 5,
                                    z: (Math.random() - 0.5) * 10
                                };
                                lastHitBy = 'player';
                            }
                        }
                    } else {
                        player.swing();
                    }
                }
                
                // Update game objects
                player.update(deltaTime);
                aiPlayer.update(deltaTime);
                updateAI(deltaTime);
                updateBall(deltaTime);
                
                // Dynamic camera
                const targetCameraX = player.group.position.x + mouseX * 5;
                const targetCameraZ = player.group.position.z + cameraDistance;
                const targetCameraY = cameraHeight + mouseY * 3;
                
                camera.position.x += (targetCameraX - camera.position.x) * deltaTime * 5;
                camera.position.y += (targetCameraY - camera.position.y) * deltaTime * 5;
                camera.position.z += (targetCameraZ - camera.position.z) * deltaTime * 5;
                
                const lookAtY = player.group.position.y + mouseY * 2;
                camera.lookAt(player.group.position.x, lookAtY, player.group.position.z - 3);
                
                // Update score display
                let serverIndicator = currentServer === 'player' ? '' : '';
                let aiServerIndicator = currentServer === 'ai' ? '' : '';
                document.getElementById('score').innerHTML = `Player ${serverIndicator}: ${playerScore} | AI ${aiServerIndicator}: ${aiScore}`;
                
                // Show serve position hint
                if (serving && currentServer === 'player') {
                    document.getElementById('info').innerHTML = `
                        <strong>CONTROLS:</strong><br>
                        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move<br>
                        <span class="key">SPACE</span> - Swing / Serve<br>
                        <span class="key">SHIFT</span> - Sprint<br>
                        Mouse - Look Around<br>
                        <br>
                        <strong style="color: #ffff00;"> SERVE: Move behind the service line!</strong>
                    `;
                } else {
                    document.getElementById('info').innerHTML = `
                        <strong>CONTROLS:</strong><br>
                        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move<br>
                        <span class="key">SPACE</span> - Swing / Serve<br>
                        <span class="key">SHIFT</span> - Sprint<br>
                        Mouse - Look Around
                    `;
                }
                
                // Render
                renderer.render(scene, camera);
            }
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Start the game
            animate();
        }
    </script>
</body>
</html>
